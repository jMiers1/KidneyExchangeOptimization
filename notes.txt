Mode
1. PC-TSP as basic model > Those can be passed to any solver such as CPLEX, it will solve them using with a standard algorithm, usually some form of Branch&Bound 
2. Idea: If we identify an internal structure in the problem, we may be able to solve the problem more efficiently > In this paper: Idea has multiple layers to it      1) We could like to not fully rely on the CPEX engine but customize the solution generation process (devise a modified B&B scheme)     2) We see that the most basic model formulation with one decision variable per arc being 0 or 1 depending on if the arc is part of the          solution may be not ideal, we want to rather increase the level of aggregation an define solution structures, i.e. cycles and chains as          decision element           -> one binary indicator per structure: is it part of the solution (Master Problem)                -> problem: exponential number of variables in such a pattern-based formulation, we need an efficient process of determining which                    patterns are potentially interesting                    -> Column Generation: We start with some subset of patterns (Restricted Master Problem)                          -> we apply some test to see if we did leave something on the table: Solve an associated Pricing Problem, 2 outcomes possible:                                a) The optimal solution to the pricing problem has negative reduced cost (PP is a min problem) or is 0                                b) The optimal solution to the PP has positive reduced cost                                   -> Inside the pricing problem: We construct another solution column, i.e. a pattern (eg a chain or a cycle) 
3. If we are not solving only an LP with many CV but an IP (MIP), we need to embed this logic into a B&B tree logic, we call the resulting algorithm a Branch&Price framework since at each node in the resulting tree, we apply first the pricing: We solve the column generation (Until we have negative reduced cost or only some number (eg 1) step?) , afterwards we branch (other than branch and bound where we simply limit the domain of the original atomic variables, we now apply a cut> this cut can be done either in terms of the pattern-based or the original varaibles   > problem: pattern: if we forbid one of the million patterns, this won’t have any noticeable effect, if we enforce one of the patterns to =1, this has a huhge impact      > we typically branch on the atomic variables, i.e, those inside the pricing problems          > in doing so, we effectively put constraints into the pricing problem, the structure of the RMP remains the same 
4. This is where the paper tries to make a contribution: How to solve the PP: It used multivariate decision diagramsA node can be in at most one chain or cycle      > If a node is in a chain, it will have to be an NDD & If a node is in a cycle, it has to be a PDP      > There are many duplicate solutions       a) orientation-invariance: 1-2-3-4-5-1 == 1-5-4-3-2-1       b) starting point invariance: 1-2-3-4-5-1 == 2-3-4-5-1-2 + decomposition principle: If we have a large set P, and we try to find an optimal solution over P and we are able to cut up P such that we have      - disjoint subsets P1, … , P_n      - dont loose any solutions in doing so,       - solve(P1) + … + solve(P_n) < solve(P) (~like triangle inequality)-> we have effectively gained computation time-> MDDs can capture this: We start with the original graph G = (N,A),  and try to cut it up into smaller, more manageable pieces and try to solve the MDD on these individual pieces     -> what is a clever way of cutting up the graph?